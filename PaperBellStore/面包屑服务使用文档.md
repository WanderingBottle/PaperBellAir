# 面包屑服务使用文档

## 目录

- [概述](#概述)
- [组件说明](#组件说明)
- [快速开始](#快速开始)
- [详细使用步骤](#详细使用步骤)
- [配置说明](#配置说明)
- [示例代码](#示例代码)
- [注意事项](#注意事项)
- [故障排除](#故障排除)

## 概述

面包屑服务（Breadcrumb Service）是一个用于在页面顶栏显示面包屑导航的功能模块。它能够自动从 ABP 框架的菜单配置中获取菜单信息，并将面包屑导航显示在页面顶栏，提供类似 ABP 原生组件的用户体验。

### 主要特性

- ✅ 自动从菜单配置中获取菜单信息
- ✅ 支持嵌套菜单的递归查找
- ✅ 自动将面包屑移动到页面顶栏
- ✅ 页面切换时自动清理旧面包屑
- ✅ 使用 ABP 原生样式，保持界面一致性
- ✅ 支持多级菜单路径（首页 > 父菜单 > 当前菜单）

## 组件说明

### 核心组件

1. **BreadcrumbComponentBase** (`src/PaperBellStore.Blazor/Services/BreadcrumbComponentBase.cs`)

   - 带面包屑功能的组件基类
   - 自动处理菜单查找和面包屑初始化
   - 在页面渲染后自动将面包屑移动到顶栏

2. **BreadcrumbService** (`src/PaperBellStore.Blazor/Services/BreadcrumbService.cs`)

   - 面包屑服务，负责面包屑的移动和清理
   - 使用 JavaScript 将面包屑元素移动到顶栏
   - 监听页面导航事件，自动清理旧面包屑

3. **PageBreadcrumb** (`src/PaperBellStore.Blazor/Components/PageBreadcrumb.razor`)
   - 面包屑 UI 组件
   - 渲染面包屑导航的 HTML 结构
   - 使用 ABP 原生的 `lpx-breadcrumb` 样式类

## 快速开始

### 1. 在页面中继承基类

```razor
@page "/your-page"
@using PaperBellStore.Blazor.Services
@inherits BreadcrumbComponentBase
@implements IAsyncDisposable

<PageTitle>页面标题</PageTitle>

<PageBreadcrumb BreadcrumbId="@BreadcrumbId"
                HomeMenu="@HomeMenu"
                ParentMenu="@ParentMenu"
                CurrentMenu="@CurrentMenu" />

<!-- 页面内容 -->
```

### 2. 实现必需的抽象属性

```csharp
public partial class YourPage
{
    // 面包屑元素的唯一 ID
    protected override string BreadcrumbId => "your-page-breadcrumb";

    // 当前页面路径（用于判断是否离开页面）
    protected override string CurrentPagePath => "/your-page";

    // 菜单项路径数组：首页 > 父菜单 > 当前菜单
    protected override string[] MenuItemPaths => new[]
    {
        PaperBellStoreMenus.Home,           // 首页
        PaperBellStoreMenus.ParentMenu,     // 父菜单名称
        PaperBellStoreMenus.CurrentMenu     // 当前菜单名称
    };
}
```

### 3. 确保菜单已配置

在 `PaperBellStoreMenuContributor.cs` 中确保菜单已正确配置：

```csharp
var parentMenu = new ApplicationMenuItem(
    PaperBellStoreMenus.ParentMenu,
    l["Menu:ParentMenu"],
    icon: "fas fa-icon",
    order: 1
);

parentMenu.AddItem(new ApplicationMenuItem(
    PaperBellStoreMenus.CurrentMenu,
    l["Menu:CurrentMenu"],
    "/your-page",
    icon: "fas fa-icon"
));

administration.AddItem(parentMenu);
```

## 详细使用步骤

### 步骤 1：创建页面文件

创建 Razor 页面文件（例如 `YourPage.razor`）：

```razor
@page "/your-page"
@using PaperBellStore.Blazor.Services
@inherits BreadcrumbComponentBase
@implements IAsyncDisposable

<PageTitle>您的页面</PageTitle>

<PageBreadcrumb BreadcrumbId="@BreadcrumbId"
                HomeMenu="@HomeMenu"
                ParentMenu="@ParentMenu"
                CurrentMenu="@CurrentMenu" />

<div class="container-fluid">
    <!-- 您的页面内容 -->
</div>
```

### 步骤 2：创建代码后置文件

创建对应的代码后置文件（例如 `YourPage.razor.cs`）：

```csharp
using PaperBellStore.Blazor.Menus;

namespace PaperBellStore.Blazor.Components.Pages;

public partial class YourPage
{
    // 面包屑元素的唯一 ID（必须唯一）
    protected override string BreadcrumbId => "your-page-breadcrumb";

    // 当前页面路径（必须与 @page 指令中的路径匹配）
    protected override string CurrentPagePath => "/your-page";

    // 菜单项路径数组
    // 格式：[首页菜单名称, 父菜单名称, 当前菜单名称]
    // 如果只有两级菜单，可以只提供两个元素：[首页菜单名称, 当前菜单名称]
    protected override string[] MenuItemPaths => new[]
    {
        PaperBellStoreMenus.Home,           // 首页
        PaperBellStoreMenus.ParentMenu,     // 父菜单（如果存在）
        PaperBellStoreMenus.CurrentMenu     // 当前菜单
    };

    // 其他页面逻辑...
}
```

### 步骤 3：定义菜单常量

在 `PaperBellStoreMenus.cs` 中定义菜单常量（如果还没有）：

```csharp
namespace PaperBellStore.Blazor.Menus;

public class PaperBellStoreMenus
{
    private const string Prefix = "PaperBellStore";
    public const string Home = Prefix + ".Home";
    public const string ParentMenu = Prefix + ".ParentMenu";  // 新增
    public const string CurrentMenu = Prefix + ".CurrentMenu"; // 新增
}
```

### 步骤 4：配置菜单

在 `PaperBellStoreMenuContributor.cs` 中配置菜单：

```csharp
// 创建父菜单
var parentMenu = new ApplicationMenuItem(
    PaperBellStoreMenus.ParentMenu,
    l["Menu:ParentMenu"],
    icon: "fas fa-folder",
    order: 1
);

// 添加子菜单
parentMenu.AddItem(new ApplicationMenuItem(
    PaperBellStoreMenus.CurrentMenu,
    l["Menu:CurrentMenu"],
    "/your-page",
    icon: "fas fa-file"
));

// 将父菜单添加到管理菜单下
var administration = context.Menu.GetAdministration();
administration.AddItem(parentMenu);
```

### 步骤 5：添加本地化资源

在 `zh-Hans.json` 中添加本地化文本：

```json
{
  "Menu:ParentMenu": "父菜单",
  "Menu:CurrentMenu": "当前菜单"
}
```

## 配置说明

### BreadcrumbId

- **类型**: `string`
- **说明**: 面包屑元素的唯一标识符
- **要求**: 必须在整个应用中唯一
- **示例**: `"your-page-breadcrumb"`

### CurrentPagePath

- **类型**: `string`
- **说明**: 当前页面的路由路径
- **要求**: 必须与 `@page` 指令中的路径完全匹配
- **示例**: `"/your-page"` 或 `"/admin/users"`

### MenuItemPaths

- **类型**: `string[]`
- **说明**: 菜单项路径数组，定义面包屑的层级结构
- **格式**:
  - 三级菜单：`[首页, 父菜单, 当前菜单]`
  - 二级菜单：`[首页, 当前菜单]`
- **要求**:
  - 第一个元素必须是首页菜单名称
  - 菜单名称必须与 `PaperBellStoreMenus` 中定义的常量匹配
  - 菜单必须在 `PaperBellStoreMenuContributor` 中正确配置
- **示例**:

  ```csharp
  // 三级菜单
  new[] { PaperBellStoreMenus.Home, PaperBellStoreMenus.ParentMenu, PaperBellStoreMenus.CurrentMenu }

  // 二级菜单
  new[] { PaperBellStoreMenus.Home, PaperBellStoreMenus.CurrentMenu }
  ```

## 示例代码

### 示例 1：三级菜单（运行日志页面）

**RunningLog.razor**:

```razor
@page "/running-log"
@using PaperBellStore.Blazor.Services
@inherits BreadcrumbComponentBase
@implements IAsyncDisposable

<PageTitle>运行日志</PageTitle>

<PageBreadcrumb BreadcrumbId="@BreadcrumbId"
                HomeMenu="@HomeMenu"
                ParentMenu="@ParentMenu"
                CurrentMenu="@CurrentMenu" />

<div class="container-fluid">
    <!-- 页面内容 -->
</div>
```

**RunningLog.razor.cs**:

```csharp
using PaperBellStore.Blazor.Menus;

namespace PaperBellStore.Blazor.Components.Pages;

public partial class RunningLog : IAsyncDisposable
{
    protected override string BreadcrumbId => "log-test-breadcrumb-container";
    protected override string CurrentPagePath => "/running-log";
    protected override string[] MenuItemPaths => new[]
    {
        PaperBellStoreMenus.Home,              // 首页
        PaperBellStoreMenus.RunningLogGroup,   // 日志管理（父菜单）
        PaperBellStoreMenus.RunningLog         // 运行日志（当前菜单）
    };

    // 其他代码...
}
```

**菜单配置**:

```csharp
// 在 PaperBellStoreMenuContributor.cs 中
var logTestManagement = new ApplicationMenuItem(
    PaperBellStoreMenus.RunningLogGroup,
    l["Menu:RunningLogGroup"],
    icon: "fas fa-file-alt",
    order: 2
);

logTestManagement.AddItem(new ApplicationMenuItem(
    PaperBellStoreMenus.RunningLog,
    l["Menu:RunningLog"],
    "/running-log",
    icon: "fas fa-bug"
));

administration.AddItem(logTestManagement);
```

**显示效果**: `首页图标 > 日志管理 > 运行日志`

### 示例 2：二级菜单

**SimplePage.razor**:

```razor
@page "/simple-page"
@using PaperBellStore.Blazor.Services
@inherits BreadcrumbComponentBase
@implements IAsyncDisposable

<PageTitle>简单页面</PageTitle>

<PageBreadcrumb BreadcrumbId="@BreadcrumbId"
                HomeMenu="@HomeMenu"
                ParentMenu="@ParentMenu"
                CurrentMenu="@CurrentMenu" />
```

**SimplePage.razor.cs**:

```csharp
using PaperBellStore.Blazor.Menus;

namespace PaperBellStore.Blazor.Components.Pages;

public partial class SimplePage : IAsyncDisposable
{
    protected override string BreadcrumbId => "simple-page-breadcrumb";
    protected override string CurrentPagePath => "/simple-page";

    // 二级菜单：只有首页和当前菜单
    protected override string[] MenuItemPaths => new[]
    {
        PaperBellStoreMenus.Home,      // 首页
        PaperBellStoreMenus.SimplePage // 当前菜单（同时也是父菜单）
    };
}
```

**显示效果**: `首页图标 > 简单页面`

## 注意事项

### 1. 必须实现 IAsyncDisposable

页面必须实现 `IAsyncDisposable` 接口，以确保在页面卸载时正确清理资源：

```csharp
public partial class YourPage : IAsyncDisposable
{
    // 基类已经实现了 DisposeAsync，通常不需要重写
    // 如果需要额外的清理逻辑，可以重写：
    public override async ValueTask DisposeAsync()
    {
        // 您的清理逻辑
        await base.DisposeAsync();
    }
}
```

### 2. 不要重写 OnAfterRenderAsync（除非必要）

基类已经在 `OnAfterRenderAsync` 中处理了面包屑的移动。如果必须重写，请确保调用基类方法：

```csharp
protected override async Task OnAfterRenderAsync(bool firstRender)
{
    // 先调用基类方法
    await base.OnAfterRenderAsync(firstRender);

    // 您的额外逻辑
}
```

### 3. 菜单名称必须匹配

`MenuItemPaths` 中的菜单名称必须与以下内容完全匹配：

- `PaperBellStoreMenus` 中定义的常量
- `PaperBellStoreMenuContributor` 中创建菜单时使用的名称

### 4. 面包屑 ID 必须唯一

每个页面的 `BreadcrumbId` 必须在整个应用中唯一，避免冲突。

### 5. 页面路径必须匹配

`CurrentPagePath` 必须与 `@page` 指令中的路径完全匹配（包括大小写）。

### 6. 菜单配置顺序

菜单必须在 `PaperBellStoreMenuContributor` 中正确配置，并且菜单层级关系必须与 `MenuItemPaths` 中定义的路径一致。

## 故障排除

### 问题 1：面包屑没有显示在顶栏

**可能原因**:

1. 没有调用 `base.OnAfterRenderAsync(firstRender)`
2. DOM 尚未完全加载
3. 顶栏元素选择器不正确

**解决方案**:

- 确保页面继承了 `BreadcrumbComponentBase` 并调用了基类方法
- 检查浏览器控制台是否有 JavaScript 错误
- 确认顶栏元素存在且选择器正确

### 问题 2：菜单项找不到

**可能原因**:

1. 菜单名称不匹配
2. 菜单未正确配置
3. 菜单在嵌套结构中，但查找逻辑有问题

**解决方案**:

- 检查 `MenuItemPaths` 中的菜单名称是否与 `PaperBellStoreMenus` 常量匹配
- 确认菜单在 `PaperBellStoreMenuContributor` 中已正确配置
- 使用递归查找（基类已实现）支持嵌套菜单

### 问题 3：面包屑显示为空

**可能原因**:

1. `HomeMenu`、`ParentMenu` 或 `CurrentMenu` 为 `null`
2. 菜单的 `DisplayName` 为空

**解决方案**:

- 检查菜单配置，确保菜单已正确创建
- 确认菜单的本地化资源已配置
- 在 `OnInitializedAsync` 中检查菜单项是否正确获取

### 问题 4：编译错误：找不到 IEnumerable

**解决方案**:
确保 `BreadcrumbComponentBase.cs` 文件顶部包含：

```csharp
using System.Collections.Generic;
```

### 问题 5：页面切换时旧面包屑未清理

**可能原因**:

1. 页面未实现 `IAsyncDisposable`
2. `DisposeAsync` 未正确调用

**解决方案**:

- 确保页面实现了 `IAsyncDisposable`
- 基类已自动处理清理，通常不需要额外操作

## 技术实现细节

### 工作流程

1. **初始化阶段** (`OnInitializedAsync`):

   - 从菜单管理器获取主菜单
   - 使用递归查找方法找到对应的菜单项
   - 初始化 `BreadcrumbService`

2. **渲染阶段** (`OnAfterRenderAsync`):

   - 等待 DOM 完全渲染
   - 调用 `BreadcrumbService.MoveToTopBarAsync()`
   - JavaScript 将面包屑元素克隆并移动到顶栏

3. **清理阶段** (`DisposeAsync`):
   - 页面卸载时自动清理顶栏中的面包屑
   - 取消导航事件订阅

### 递归查找算法

基类实现了递归查找算法，支持在嵌套菜单结构中查找菜单项：

```csharp
private ApplicationMenuItem? FindMenuItemRecursive(
    IEnumerable<ApplicationMenuItem> items,
    string menuName)
{
    foreach (var item in items)
    {
        if (item.Name == menuName)
            return item;

        if (item.Items != null && item.Items.Any())
        {
            var found = FindMenuItemRecursive(item.Items, menuName);
            if (found != null)
                return found;
        }
    }
    return null;
}
```

### JavaScript 移动逻辑

`BreadcrumbService` 使用 JavaScript 将面包屑元素移动到顶栏：

- 查找顶栏容器（支持多种选择器）
- 克隆面包屑元素
- 移除内联样式，使用原生 CSS
- 插入到合适的位置
- 隐藏原始元素

## 相关文件

- `src/PaperBellStore.Blazor/Services/BreadcrumbComponentBase.cs` - 组件基类
- `src/PaperBellStore.Blazor/Services/BreadcrumbService.cs` - 面包屑服务
- `src/PaperBellStore.Blazor/Components/PageBreadcrumb.razor` - 面包屑 UI 组件
- `src/PaperBellStore.Blazor/Components/Pages/RunningLog.razor` - 示例页面
- `src/PaperBellStore.Blazor/Menus/PaperBellStoreMenuContributor.cs` - 菜单配置

## 更新日志

### 2024-01-XX

- 初始版本
- 支持三级菜单结构
- 实现递归菜单查找
- 添加重试机制确保 DOM 加载完成
- 自动清理旧面包屑

---

**文档版本**: 1.0  
**最后更新**: 2024-01-XX  
**维护者**: PaperBellStore 开发团队
